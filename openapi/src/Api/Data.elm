{-
   GraphSense API
   GraphSense API

   The version of the OpenAPI document: 0.5.2

   NOTE: This file is auto generated by the openapi-generator.
   https://github.com/openapitools/openapi-generator.git

   DO NOT EDIT THIS FILE MANUALLY.

   For more info on generating Elm code, see https://eriktim.github.io/openapi-elm/
-}


module Api.Data exposing
    ( Address
    , AddressAndEntityTags
    , AddressId
    , AddressTag
    , AddressTags
    , AddressTx(..)
    , AddressTxUtxo
    , AddressTxs
    , Block
    , Coinbase
    , Concept
    , Currency
    , CurrencyStats
    , Entity
    , EntityAddresses
    , EntityId
    , EntityTag
    , EntityTags
    , Height
    , Label
    , Link(..)
    , LinkUtxo
    , Links
    , Neighbor, NeighborNodeType(..), neighborNodeTypeVariants
    , Neighbors
    , NextPage
    , NoAddresses
    , NoTxs
    , Rate
    , Rates
    , SearchResult
    , SearchResultByCurrency
    , SearchResultLeaf
    , SearchResultLevel1
    , SearchResultLevel2
    , SearchResultLevel3
    , SearchResultLevel4
    , SearchResultLevel5
    , SearchResultLevel6
    , Stats
    , Tag
    , Tags(..)
    , Taxonomy
    , TaxonomyKey
    , Timestamp
    , Tx(..)
    , TxAccount
    , TxHash
    , TxSummary
    , TxUtxo
    , TxValue
    , Uri
    , Values
    , encodeAddress
    , encodeAddressAndEntityTags
    , encodeAddressId
    , encodeAddressTag
    , encodeAddressTags
    , encodeAddressTx
    , encodeAddressTxUtxo
    , encodeAddressTxs
    , encodeBlock
    , encodeCoinbase
    , encodeConcept
    , encodeCurrency
    , encodeCurrencyStats
    , encodeEntity
    , encodeEntityAddresses
    , encodeEntityId
    , encodeEntityTag
    , encodeEntityTags
    , encodeHeight
    , encodeLabel
    , encodeLink
    , encodeLinkUtxo
    , encodeLinks
    , encodeNeighbor
    , encodeNeighbors
    , encodeNextPage
    , encodeNoAddresses
    , encodeNoTxs
    , encodeRate
    , encodeRates
    , encodeSearchResult
    , encodeSearchResultByCurrency
    , encodeSearchResultLeaf
    , encodeSearchResultLevel1
    , encodeSearchResultLevel2
    , encodeSearchResultLevel3
    , encodeSearchResultLevel4
    , encodeSearchResultLevel5
    , encodeSearchResultLevel6
    , encodeStats
    , encodeTag
    , encodeTags
    , encodeTaxonomy
    , encodeTaxonomyKey
    , encodeTimestamp
    , encodeTx
    , encodeTxAccount
    , encodeTxHash
    , encodeTxSummary
    , encodeTxUtxo
    , encodeTxValue
    , encodeUri
    , encodeValues
    , addressDecoder
    , addressAndEntityTagsDecoder
    , addressIdDecoder
    , addressTagDecoder
    , addressTagsDecoder
    , addressTxDecoder
    , addressTxUtxoDecoder
    , addressTxsDecoder
    , blockDecoder
    , coinbaseDecoder
    , conceptDecoder
    , currencyDecoder
    , currencyStatsDecoder
    , entityDecoder
    , entityAddressesDecoder
    , entityIdDecoder
    , entityTagDecoder
    , entityTagsDecoder
    , heightDecoder
    , labelDecoder
    , linkDecoder
    , linkUtxoDecoder
    , linksDecoder
    , neighborDecoder
    , neighborsDecoder
    , nextPageDecoder
    , noAddressesDecoder
    , noTxsDecoder
    , rateDecoder
    , ratesDecoder
    , searchResultDecoder
    , searchResultByCurrencyDecoder
    , searchResultLeafDecoder
    , searchResultLevel1Decoder
    , searchResultLevel2Decoder
    , searchResultLevel3Decoder
    , searchResultLevel4Decoder
    , searchResultLevel5Decoder
    , searchResultLevel6Decoder
    , statsDecoder
    , tagDecoder
    , tagsDecoder
    , taxonomyDecoder
    , taxonomyKeyDecoder
    , timestampDecoder
    , txDecoder
    , txAccountDecoder
    , txHashDecoder
    , txSummaryDecoder
    , txUtxoDecoder
    , txValueDecoder
    , uriDecoder
    , valuesDecoder
    )

import Api
import Dict
import Json.Decode
import Json.Encode


-- MODEL


type alias Address =
    { address : String
    , entity : Int
    , balance : Values
    , firstTx : TxSummary
    , lastTx : TxSummary
    , inDegree : Int
    , outDegree : Int
    , noIncomingTxs : Int
    , noOutgoingTxs : Int
    , totalReceived : Values
    , totalSpent : Values
    , tags : Maybe (List (AddressTag))
    }


type alias AddressAndEntityTags =
    { entityTags : List (EntityTag)
    , addressTags : List (AddressTag)
    }


{-| Address
-}
type alias AddressId =
    { }


type alias AddressTag =
    { label : String
    , category : Maybe String
    , abuse : Maybe String
    , tagpackUri : Maybe String
    , source : Maybe String
    , lastmod : Maybe Int
    , active : Bool
    , isPublic : Maybe Bool
    , isClusterDefiner : Maybe Bool
    , currency : String
    , address : String
    }


type alias AddressTags =
    { addressTags : List (AddressTag)
    , nextPage : Maybe String
    }


type AddressTx
    = AddressTxAddressTxUtxo AddressTxUtxo
    | AddressTxTxAccount TxAccount



type alias AddressTxUtxo =
    { txType : String
    , txHash : String
    , coinbase : Bool
    , height : Int
    , timestamp : Int
    , value : Values
    }


type alias AddressTxs =
    { nextPage : Maybe String
    , addressTxs : Maybe (List (AddressTx))
    }


type alias Block =
    { blockHash : Maybe String
    , height : Maybe Int
    , noTxs : Maybe Int
    , timestamp : Maybe Int
    }


{-| Coinbase transaction flag
-}
type alias Coinbase =
    { }


type alias Concept =
    { label : String
    , taxonomy : String
    , uri : String
    , description : String
    , id : String
    }


{-| crypto currency code
-}
type alias Currency =
    { }


type alias CurrencyStats =
    { name : Maybe String
    , noBlocks : Maybe Int
    , noAddressRelations : Maybe Int
    , noAddresses : Maybe Int
    , noEntities : Maybe Int
    , noTxs : Maybe Int
    , noLabels : Maybe Int
    , noTaggedAddresses : Maybe Int
    , timestamp : Maybe Int
    }


type alias Entity =
    { entity : Int
    , rootAddress : String
    , balance : Values
    , firstTx : TxSummary
    , lastTx : TxSummary
    , inDegree : Int
    , outDegree : Int
    , noAddresses : Int
    , noIncomingTxs : Int
    , noOutgoingTxs : Int
    , totalReceived : Values
    , totalSpent : Values
    , tags : Maybe AddressAndEntityTags
    }


type alias EntityAddresses =
    { nextPage : Maybe String
    , addresses : Maybe (List (Address))
    }


{-| Entity id
-}
type alias EntityId =
    { }


type alias EntityTag =
    { label : String
    , category : Maybe String
    , abuse : Maybe String
    , tagpackUri : Maybe String
    , source : Maybe String
    , lastmod : Maybe Int
    , active : Bool
    , isPublic : Maybe Bool
    , isClusterDefiner : Maybe Bool
    , currency : String
    , entity : Int
    , address : Maybe String
    }


type alias EntityTags =
    { entityTags : List (EntityTag)
    , nextPage : Maybe String
    }


{-| Height
-}
type alias Height =
    { }


{-| Label
-}
type alias Label =
    { }


type Link
    = LinkLinkUtxo LinkUtxo
    | LinkTxAccount TxAccount



type alias LinkUtxo =
    { txType : String
    , txHash : String
    , height : Int
    , timestamp : Int
    , inputValue : Values
    , outputValue : Values
    }


type alias Links =
    { nextPage : Maybe String
    , links : Maybe (List (Link))
    }


type alias Neighbor =
    { id : String
    , nodeType : NeighborNodeType
    , labels : Maybe (List (String))
    , balance : Values
    , received : Values
    , value : Values
    , noTxs : Int
    }


type NeighborNodeType
    = NeighborNodeTypeAddress
    | NeighborNodeTypeEntity


neighborNodeTypeVariants : List NeighborNodeType
neighborNodeTypeVariants =
    [ NeighborNodeTypeAddress
    , NeighborNodeTypeEntity
    ]


type alias Neighbors =
    { nextPage : Maybe String
    , neighbors : Maybe (List (Neighbor))
    }


type alias NextPage =
    { }


{-| number of contained addresses
-}
type alias NoAddresses =
    { }


{-| number of transactions
-}
type alias NoTxs =
    { }


type alias Rate =
    { code : Maybe String
    , value : Maybe Float
    }


type alias Rates =
    { height : Maybe Int
    , rates : Maybe (List (Rate))
    }


type alias SearchResult =
    { currencies : Maybe (List (SearchResultByCurrency))
    , labels : Maybe (List (String))
    }


type alias SearchResultByCurrency =
    { currency : Maybe String
    , addresses : Maybe (List (String))
    , txs : Maybe (List (String))
    }


type alias SearchResultLeaf =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    }


type alias SearchResultLevel1 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLevel2))
    }


type alias SearchResultLevel2 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLevel3))
    }


type alias SearchResultLevel3 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLevel4))
    }


type alias SearchResultLevel4 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLevel5))
    }


type alias SearchResultLevel5 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLevel6))
    }


type alias SearchResultLevel6 =
    { node : Maybe Entity
    , relation : Maybe Neighbor
    , matchingAddresses : Maybe (List (Address))
    , paths : Maybe (List (SearchResultLeaf))
    }


type alias Stats =
    { currencies : Maybe (List (CurrencyStats))
    , version : Maybe String
    , requestTimestamp : Maybe String
    }


type alias Tag =
    { label : String
    , category : Maybe String
    , abuse : Maybe String
    , tagpackUri : Maybe String
    , source : Maybe String
    , lastmod : Maybe Int
    , active : Bool
    , isPublic : Maybe Bool
    , isClusterDefiner : Maybe Bool
    , currency : String
    }


type Tags
    = TagsAddressTags AddressTags
    | TagsEntityTags EntityTags



type alias Taxonomy =
    { taxonomy : String
    , uri : String
    }


{-| Taxonomy
-}
type alias TaxonomyKey =
    { }


{-| Timestamp
-}
type alias Timestamp =
    { }


type Tx
    = TxTxAccount TxAccount
    | TxTxUtxo TxUtxo



type alias TxAccount =
    { txType : String
    , txHash : String
    , height : Int
    , timestamp : Int
    , value : Values
    , fromAddress : String
    , toAddress : String
    }


{-| Transaction hash
-}
type alias TxHash =
    { }


type alias TxSummary =
    { height : Int
    , timestamp : Int
    , txHash : String
    }


type alias TxUtxo =
    { txType : String
    , txHash : String
    , coinbase : Bool
    , height : Int
    , inputs : Maybe (List (TxValue))
    , outputs : Maybe (List (TxValue))
    , timestamp : Int
    , totalInput : Values
    , totalOutput : Values
    }


type alias TxValue =
    { address : List (String)
    , value : Values
    }


{-| URI
-}
type alias Uri =
    { }


type alias Values =
    { fiatValues : Maybe (List (Rate))
    , value : Maybe Int
    }


-- ENCODER


encodeAddress : Address -> Json.Encode.Value
encodeAddress =
    encodeObject << encodeAddressPairs


encodeAddressWithTag : ( String, String ) -> Address -> Json.Encode.Value
encodeAddressWithTag (tagField, tag) model =
    encodeObject (encodeAddressPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressPairs : Address -> List EncodedField
encodeAddressPairs model =
    let
        pairs =
            [ encode "address" Json.Encode.string model.address
            , encode "entity" Json.Encode.int model.entity
            , encode "balance" encodeValues model.balance
            , encode "first_tx" encodeTxSummary model.firstTx
            , encode "last_tx" encodeTxSummary model.lastTx
            , encode "in_degree" Json.Encode.int model.inDegree
            , encode "out_degree" Json.Encode.int model.outDegree
            , encode "no_incoming_txs" Json.Encode.int model.noIncomingTxs
            , encode "no_outgoing_txs" Json.Encode.int model.noOutgoingTxs
            , encode "total_received" encodeValues model.totalReceived
            , encode "total_spent" encodeValues model.totalSpent
            , maybeEncode "tags" (Json.Encode.list encodeAddressTag) model.tags
            ]
    in
    pairs


encodeAddressAndEntityTags : AddressAndEntityTags -> Json.Encode.Value
encodeAddressAndEntityTags =
    encodeObject << encodeAddressAndEntityTagsPairs


encodeAddressAndEntityTagsWithTag : ( String, String ) -> AddressAndEntityTags -> Json.Encode.Value
encodeAddressAndEntityTagsWithTag (tagField, tag) model =
    encodeObject (encodeAddressAndEntityTagsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressAndEntityTagsPairs : AddressAndEntityTags -> List EncodedField
encodeAddressAndEntityTagsPairs model =
    let
        pairs =
            [ encode "entity_tags" (Json.Encode.list encodeEntityTag) model.entityTags
            , encode "address_tags" (Json.Encode.list encodeAddressTag) model.addressTags
            ]
    in
    pairs


encodeAddressId : AddressId -> Json.Encode.Value
encodeAddressId =
    encodeObject << encodeAddressIdPairs


encodeAddressIdWithTag : ( String, String ) -> AddressId -> Json.Encode.Value
encodeAddressIdWithTag (tagField, tag) model =
    encodeObject (encodeAddressIdPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressIdPairs : AddressId -> List EncodedField
encodeAddressIdPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeAddressTag : AddressTag -> Json.Encode.Value
encodeAddressTag =
    encodeObject << encodeAddressTagPairs


encodeAddressTagWithTag : ( String, String ) -> AddressTag -> Json.Encode.Value
encodeAddressTagWithTag (tagField, tag) model =
    encodeObject (encodeAddressTagPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressTagPairs : AddressTag -> List EncodedField
encodeAddressTagPairs model =
    let
        pairs =
            [ encode "label" Json.Encode.string model.label
            , maybeEncode "category" Json.Encode.string model.category
            , maybeEncode "abuse" Json.Encode.string model.abuse
            , maybeEncode "tagpack_uri" Json.Encode.string model.tagpackUri
            , maybeEncode "source" Json.Encode.string model.source
            , maybeEncode "lastmod" Json.Encode.int model.lastmod
            , encode "active" Json.Encode.bool model.active
            , maybeEncode "is_public" Json.Encode.bool model.isPublic
            , maybeEncode "is_cluster_definer" Json.Encode.bool model.isClusterDefiner
            , encode "currency" Json.Encode.string model.currency
            , encode "address" Json.Encode.string model.address
            ]
    in
    pairs


encodeAddressTags : AddressTags -> Json.Encode.Value
encodeAddressTags =
    encodeObject << encodeAddressTagsPairs


encodeAddressTagsWithTag : ( String, String ) -> AddressTags -> Json.Encode.Value
encodeAddressTagsWithTag (tagField, tag) model =
    encodeObject (encodeAddressTagsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressTagsPairs : AddressTags -> List EncodedField
encodeAddressTagsPairs model =
    let
        pairs =
            [ encode "address_tags" (Json.Encode.list encodeAddressTag) model.addressTags
            , maybeEncode "next_page" Json.Encode.string model.nextPage
            ]
    in
    pairs


encodeAddressTx : AddressTx -> Json.Encode.Value
encodeAddressTx model =
    case model of
        AddressTxTxAccount subModel ->
            encodeTxAccountWithTag ("txType", "account") subModel

        AddressTxAddressTxUtxo subModel ->
            encodeAddressTxUtxoWithTag ("txType", "utxo") subModel




encodeAddressTxUtxo : AddressTxUtxo -> Json.Encode.Value
encodeAddressTxUtxo =
    encodeObject << encodeAddressTxUtxoPairs


encodeAddressTxUtxoWithTag : ( String, String ) -> AddressTxUtxo -> Json.Encode.Value
encodeAddressTxUtxoWithTag (tagField, tag) model =
    encodeObject (encodeAddressTxUtxoPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressTxUtxoPairs : AddressTxUtxo -> List EncodedField
encodeAddressTxUtxoPairs model =
    let
        pairs =
            [ encode "tx_type" Json.Encode.string model.txType
            , encode "tx_hash" Json.Encode.string model.txHash
            , encode "coinbase" Json.Encode.bool model.coinbase
            , encode "height" Json.Encode.int model.height
            , encode "timestamp" Json.Encode.int model.timestamp
            , encode "value" encodeValues model.value
            ]
    in
    pairs


encodeAddressTxs : AddressTxs -> Json.Encode.Value
encodeAddressTxs =
    encodeObject << encodeAddressTxsPairs


encodeAddressTxsWithTag : ( String, String ) -> AddressTxs -> Json.Encode.Value
encodeAddressTxsWithTag (tagField, tag) model =
    encodeObject (encodeAddressTxsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeAddressTxsPairs : AddressTxs -> List EncodedField
encodeAddressTxsPairs model =
    let
        pairs =
            [ maybeEncode "next_page" Json.Encode.string model.nextPage
            , maybeEncode "address_txs" (Json.Encode.list encodeAddressTx) model.addressTxs
            ]
    in
    pairs


encodeBlock : Block -> Json.Encode.Value
encodeBlock =
    encodeObject << encodeBlockPairs


encodeBlockWithTag : ( String, String ) -> Block -> Json.Encode.Value
encodeBlockWithTag (tagField, tag) model =
    encodeObject (encodeBlockPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeBlockPairs : Block -> List EncodedField
encodeBlockPairs model =
    let
        pairs =
            [ maybeEncode "block_hash" Json.Encode.string model.blockHash
            , maybeEncode "height" Json.Encode.int model.height
            , maybeEncode "no_txs" Json.Encode.int model.noTxs
            , maybeEncode "timestamp" Json.Encode.int model.timestamp
            ]
    in
    pairs


encodeCoinbase : Coinbase -> Json.Encode.Value
encodeCoinbase =
    encodeObject << encodeCoinbasePairs


encodeCoinbaseWithTag : ( String, String ) -> Coinbase -> Json.Encode.Value
encodeCoinbaseWithTag (tagField, tag) model =
    encodeObject (encodeCoinbasePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeCoinbasePairs : Coinbase -> List EncodedField
encodeCoinbasePairs model =
    let
        pairs =
            ]
    in
    pairs


encodeConcept : Concept -> Json.Encode.Value
encodeConcept =
    encodeObject << encodeConceptPairs


encodeConceptWithTag : ( String, String ) -> Concept -> Json.Encode.Value
encodeConceptWithTag (tagField, tag) model =
    encodeObject (encodeConceptPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeConceptPairs : Concept -> List EncodedField
encodeConceptPairs model =
    let
        pairs =
            [ encode "label" Json.Encode.string model.label
            , encode "taxonomy" Json.Encode.string model.taxonomy
            , encode "uri" Json.Encode.string model.uri
            , encode "description" Json.Encode.string model.description
            , encode "id" Json.Encode.string model.id
            ]
    in
    pairs


encodeCurrency : Currency -> Json.Encode.Value
encodeCurrency =
    encodeObject << encodeCurrencyPairs


encodeCurrencyWithTag : ( String, String ) -> Currency -> Json.Encode.Value
encodeCurrencyWithTag (tagField, tag) model =
    encodeObject (encodeCurrencyPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeCurrencyPairs : Currency -> List EncodedField
encodeCurrencyPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeCurrencyStats : CurrencyStats -> Json.Encode.Value
encodeCurrencyStats =
    encodeObject << encodeCurrencyStatsPairs


encodeCurrencyStatsWithTag : ( String, String ) -> CurrencyStats -> Json.Encode.Value
encodeCurrencyStatsWithTag (tagField, tag) model =
    encodeObject (encodeCurrencyStatsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeCurrencyStatsPairs : CurrencyStats -> List EncodedField
encodeCurrencyStatsPairs model =
    let
        pairs =
            [ maybeEncode "name" Json.Encode.string model.name
            , maybeEncode "no_blocks" Json.Encode.int model.noBlocks
            , maybeEncode "no_address_relations" Json.Encode.int model.noAddressRelations
            , maybeEncode "no_addresses" Json.Encode.int model.noAddresses
            , maybeEncode "no_entities" Json.Encode.int model.noEntities
            , maybeEncode "no_txs" Json.Encode.int model.noTxs
            , maybeEncode "no_labels" Json.Encode.int model.noLabels
            , maybeEncode "no_tagged_addresses" Json.Encode.int model.noTaggedAddresses
            , maybeEncode "timestamp" Json.Encode.int model.timestamp
            ]
    in
    pairs


encodeEntity : Entity -> Json.Encode.Value
encodeEntity =
    encodeObject << encodeEntityPairs


encodeEntityWithTag : ( String, String ) -> Entity -> Json.Encode.Value
encodeEntityWithTag (tagField, tag) model =
    encodeObject (encodeEntityPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeEntityPairs : Entity -> List EncodedField
encodeEntityPairs model =
    let
        pairs =
            [ encode "entity" Json.Encode.int model.entity
            , encode "root_address" Json.Encode.string model.rootAddress
            , encode "balance" encodeValues model.balance
            , encode "first_tx" encodeTxSummary model.firstTx
            , encode "last_tx" encodeTxSummary model.lastTx
            , encode "in_degree" Json.Encode.int model.inDegree
            , encode "out_degree" Json.Encode.int model.outDegree
            , encode "no_addresses" Json.Encode.int model.noAddresses
            , encode "no_incoming_txs" Json.Encode.int model.noIncomingTxs
            , encode "no_outgoing_txs" Json.Encode.int model.noOutgoingTxs
            , encode "total_received" encodeValues model.totalReceived
            , encode "total_spent" encodeValues model.totalSpent
            , maybeEncode "tags" encodeAddressAndEntityTags model.tags
            ]
    in
    pairs


encodeEntityAddresses : EntityAddresses -> Json.Encode.Value
encodeEntityAddresses =
    encodeObject << encodeEntityAddressesPairs


encodeEntityAddressesWithTag : ( String, String ) -> EntityAddresses -> Json.Encode.Value
encodeEntityAddressesWithTag (tagField, tag) model =
    encodeObject (encodeEntityAddressesPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeEntityAddressesPairs : EntityAddresses -> List EncodedField
encodeEntityAddressesPairs model =
    let
        pairs =
            [ maybeEncode "next_page" Json.Encode.string model.nextPage
            , maybeEncode "addresses" (Json.Encode.list encodeAddress) model.addresses
            ]
    in
    pairs


encodeEntityId : EntityId -> Json.Encode.Value
encodeEntityId =
    encodeObject << encodeEntityIdPairs


encodeEntityIdWithTag : ( String, String ) -> EntityId -> Json.Encode.Value
encodeEntityIdWithTag (tagField, tag) model =
    encodeObject (encodeEntityIdPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeEntityIdPairs : EntityId -> List EncodedField
encodeEntityIdPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeEntityTag : EntityTag -> Json.Encode.Value
encodeEntityTag =
    encodeObject << encodeEntityTagPairs


encodeEntityTagWithTag : ( String, String ) -> EntityTag -> Json.Encode.Value
encodeEntityTagWithTag (tagField, tag) model =
    encodeObject (encodeEntityTagPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeEntityTagPairs : EntityTag -> List EncodedField
encodeEntityTagPairs model =
    let
        pairs =
            [ encode "label" Json.Encode.string model.label
            , maybeEncode "category" Json.Encode.string model.category
            , maybeEncode "abuse" Json.Encode.string model.abuse
            , maybeEncode "tagpack_uri" Json.Encode.string model.tagpackUri
            , maybeEncode "source" Json.Encode.string model.source
            , maybeEncode "lastmod" Json.Encode.int model.lastmod
            , encode "active" Json.Encode.bool model.active
            , maybeEncode "is_public" Json.Encode.bool model.isPublic
            , maybeEncode "is_cluster_definer" Json.Encode.bool model.isClusterDefiner
            , encode "currency" Json.Encode.string model.currency
            , encode "entity" Json.Encode.int model.entity
            , maybeEncode "address" Json.Encode.string model.address
            ]
    in
    pairs


encodeEntityTags : EntityTags -> Json.Encode.Value
encodeEntityTags =
    encodeObject << encodeEntityTagsPairs


encodeEntityTagsWithTag : ( String, String ) -> EntityTags -> Json.Encode.Value
encodeEntityTagsWithTag (tagField, tag) model =
    encodeObject (encodeEntityTagsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeEntityTagsPairs : EntityTags -> List EncodedField
encodeEntityTagsPairs model =
    let
        pairs =
            [ encode "entity_tags" (Json.Encode.list encodeEntityTag) model.entityTags
            , maybeEncode "next_page" Json.Encode.string model.nextPage
            ]
    in
    pairs


encodeHeight : Height -> Json.Encode.Value
encodeHeight =
    encodeObject << encodeHeightPairs


encodeHeightWithTag : ( String, String ) -> Height -> Json.Encode.Value
encodeHeightWithTag (tagField, tag) model =
    encodeObject (encodeHeightPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeHeightPairs : Height -> List EncodedField
encodeHeightPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeLabel : Label -> Json.Encode.Value
encodeLabel =
    encodeObject << encodeLabelPairs


encodeLabelWithTag : ( String, String ) -> Label -> Json.Encode.Value
encodeLabelWithTag (tagField, tag) model =
    encodeObject (encodeLabelPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeLabelPairs : Label -> List EncodedField
encodeLabelPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeLink : Link -> Json.Encode.Value
encodeLink model =
    case model of
        LinkTxAccount subModel ->
            encodeTxAccountWithTag ("txType", "account") subModel

        LinkLinkUtxo subModel ->
            encodeLinkUtxoWithTag ("txType", "utxo") subModel




encodeLinkUtxo : LinkUtxo -> Json.Encode.Value
encodeLinkUtxo =
    encodeObject << encodeLinkUtxoPairs


encodeLinkUtxoWithTag : ( String, String ) -> LinkUtxo -> Json.Encode.Value
encodeLinkUtxoWithTag (tagField, tag) model =
    encodeObject (encodeLinkUtxoPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeLinkUtxoPairs : LinkUtxo -> List EncodedField
encodeLinkUtxoPairs model =
    let
        pairs =
            [ encode "tx_type" Json.Encode.string model.txType
            , encode "tx_hash" Json.Encode.string model.txHash
            , encode "height" Json.Encode.int model.height
            , encode "timestamp" Json.Encode.int model.timestamp
            , encode "input_value" encodeValues model.inputValue
            , encode "output_value" encodeValues model.outputValue
            ]
    in
    pairs


encodeLinks : Links -> Json.Encode.Value
encodeLinks =
    encodeObject << encodeLinksPairs


encodeLinksWithTag : ( String, String ) -> Links -> Json.Encode.Value
encodeLinksWithTag (tagField, tag) model =
    encodeObject (encodeLinksPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeLinksPairs : Links -> List EncodedField
encodeLinksPairs model =
    let
        pairs =
            [ maybeEncode "next_page" Json.Encode.string model.nextPage
            , maybeEncode "links" (Json.Encode.list encodeLink) model.links
            ]
    in
    pairs


encodeNeighbor : Neighbor -> Json.Encode.Value
encodeNeighbor =
    encodeObject << encodeNeighborPairs


encodeNeighborWithTag : ( String, String ) -> Neighbor -> Json.Encode.Value
encodeNeighborWithTag (tagField, tag) model =
    encodeObject (encodeNeighborPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeNeighborPairs : Neighbor -> List EncodedField
encodeNeighborPairs model =
    let
        pairs =
            [ encode "id" Json.Encode.string model.id
            , encode "node_type"  model.nodeType
            , maybeEncode "labels" (Json.Encode.list Json.Encode.string) model.labels
            , encode "balance" encodeValues model.balance
            , encode "received" encodeValues model.received
            , encode "value" encodeValues model.value
            , encode "no_txs" Json.Encode.int model.noTxs
            ]
    in
    pairs

stringFromNeighborNodeType : NeighborNodeType -> String
stringFromNeighborNodeType model =
    case model of
        NeighborNodeTypeAddress ->
            "address"

        NeighborNodeTypeEntity ->
            "entity"


encodeNeighborNodeType : NeighborNodeType -> Json.Encode.Value
encodeNeighborNodeType =
    Json.Encode.string << stringFromNeighborNodeType



encodeNeighbors : Neighbors -> Json.Encode.Value
encodeNeighbors =
    encodeObject << encodeNeighborsPairs


encodeNeighborsWithTag : ( String, String ) -> Neighbors -> Json.Encode.Value
encodeNeighborsWithTag (tagField, tag) model =
    encodeObject (encodeNeighborsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeNeighborsPairs : Neighbors -> List EncodedField
encodeNeighborsPairs model =
    let
        pairs =
            [ maybeEncode "next_page" Json.Encode.string model.nextPage
            , maybeEncode "neighbors" (Json.Encode.list encodeNeighbor) model.neighbors
            ]
    in
    pairs


encodeNextPage : NextPage -> Json.Encode.Value
encodeNextPage =
    encodeObject << encodeNextPagePairs


encodeNextPageWithTag : ( String, String ) -> NextPage -> Json.Encode.Value
encodeNextPageWithTag (tagField, tag) model =
    encodeObject (encodeNextPagePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeNextPagePairs : NextPage -> List EncodedField
encodeNextPagePairs model =
    let
        pairs =
            ]
    in
    pairs


encodeNoAddresses : NoAddresses -> Json.Encode.Value
encodeNoAddresses =
    encodeObject << encodeNoAddressesPairs


encodeNoAddressesWithTag : ( String, String ) -> NoAddresses -> Json.Encode.Value
encodeNoAddressesWithTag (tagField, tag) model =
    encodeObject (encodeNoAddressesPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeNoAddressesPairs : NoAddresses -> List EncodedField
encodeNoAddressesPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeNoTxs : NoTxs -> Json.Encode.Value
encodeNoTxs =
    encodeObject << encodeNoTxsPairs


encodeNoTxsWithTag : ( String, String ) -> NoTxs -> Json.Encode.Value
encodeNoTxsWithTag (tagField, tag) model =
    encodeObject (encodeNoTxsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeNoTxsPairs : NoTxs -> List EncodedField
encodeNoTxsPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeRate : Rate -> Json.Encode.Value
encodeRate =
    encodeObject << encodeRatePairs


encodeRateWithTag : ( String, String ) -> Rate -> Json.Encode.Value
encodeRateWithTag (tagField, tag) model =
    encodeObject (encodeRatePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeRatePairs : Rate -> List EncodedField
encodeRatePairs model =
    let
        pairs =
            [ maybeEncode "code" Json.Encode.string model.code
            , maybeEncode "value" Json.Encode.float model.value
            ]
    in
    pairs


encodeRates : Rates -> Json.Encode.Value
encodeRates =
    encodeObject << encodeRatesPairs


encodeRatesWithTag : ( String, String ) -> Rates -> Json.Encode.Value
encodeRatesWithTag (tagField, tag) model =
    encodeObject (encodeRatesPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeRatesPairs : Rates -> List EncodedField
encodeRatesPairs model =
    let
        pairs =
            [ maybeEncode "height" Json.Encode.int model.height
            , maybeEncode "rates" (Json.Encode.list encodeRate) model.rates
            ]
    in
    pairs


encodeSearchResult : SearchResult -> Json.Encode.Value
encodeSearchResult =
    encodeObject << encodeSearchResultPairs


encodeSearchResultWithTag : ( String, String ) -> SearchResult -> Json.Encode.Value
encodeSearchResultWithTag (tagField, tag) model =
    encodeObject (encodeSearchResultPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultPairs : SearchResult -> List EncodedField
encodeSearchResultPairs model =
    let
        pairs =
            [ maybeEncode "currencies" (Json.Encode.list encodeSearchResultByCurrency) model.currencies
            , maybeEncode "labels" (Json.Encode.list Json.Encode.string) model.labels
            ]
    in
    pairs


encodeSearchResultByCurrency : SearchResultByCurrency -> Json.Encode.Value
encodeSearchResultByCurrency =
    encodeObject << encodeSearchResultByCurrencyPairs


encodeSearchResultByCurrencyWithTag : ( String, String ) -> SearchResultByCurrency -> Json.Encode.Value
encodeSearchResultByCurrencyWithTag (tagField, tag) model =
    encodeObject (encodeSearchResultByCurrencyPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultByCurrencyPairs : SearchResultByCurrency -> List EncodedField
encodeSearchResultByCurrencyPairs model =
    let
        pairs =
            [ maybeEncode "currency" Json.Encode.string model.currency
            , maybeEncode "addresses" (Json.Encode.list Json.Encode.string) model.addresses
            , maybeEncode "txs" (Json.Encode.list Json.Encode.string) model.txs
            ]
    in
    pairs


encodeSearchResultLeaf : SearchResultLeaf -> Json.Encode.Value
encodeSearchResultLeaf =
    encodeObject << encodeSearchResultLeafPairs


encodeSearchResultLeafWithTag : ( String, String ) -> SearchResultLeaf -> Json.Encode.Value
encodeSearchResultLeafWithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLeafPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLeafPairs : SearchResultLeaf -> List EncodedField
encodeSearchResultLeafPairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            ]
    in
    pairs


encodeSearchResultLevel1 : SearchResultLevel1 -> Json.Encode.Value
encodeSearchResultLevel1 =
    encodeObject << encodeSearchResultLevel1Pairs


encodeSearchResultLevel1WithTag : ( String, String ) -> SearchResultLevel1 -> Json.Encode.Value
encodeSearchResultLevel1WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel1Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel1Pairs : SearchResultLevel1 -> List EncodedField
encodeSearchResultLevel1Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLevel2) model.paths
            ]
    in
    pairs


encodeSearchResultLevel2 : SearchResultLevel2 -> Json.Encode.Value
encodeSearchResultLevel2 =
    encodeObject << encodeSearchResultLevel2Pairs


encodeSearchResultLevel2WithTag : ( String, String ) -> SearchResultLevel2 -> Json.Encode.Value
encodeSearchResultLevel2WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel2Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel2Pairs : SearchResultLevel2 -> List EncodedField
encodeSearchResultLevel2Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLevel3) model.paths
            ]
    in
    pairs


encodeSearchResultLevel3 : SearchResultLevel3 -> Json.Encode.Value
encodeSearchResultLevel3 =
    encodeObject << encodeSearchResultLevel3Pairs


encodeSearchResultLevel3WithTag : ( String, String ) -> SearchResultLevel3 -> Json.Encode.Value
encodeSearchResultLevel3WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel3Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel3Pairs : SearchResultLevel3 -> List EncodedField
encodeSearchResultLevel3Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLevel4) model.paths
            ]
    in
    pairs


encodeSearchResultLevel4 : SearchResultLevel4 -> Json.Encode.Value
encodeSearchResultLevel4 =
    encodeObject << encodeSearchResultLevel4Pairs


encodeSearchResultLevel4WithTag : ( String, String ) -> SearchResultLevel4 -> Json.Encode.Value
encodeSearchResultLevel4WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel4Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel4Pairs : SearchResultLevel4 -> List EncodedField
encodeSearchResultLevel4Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLevel5) model.paths
            ]
    in
    pairs


encodeSearchResultLevel5 : SearchResultLevel5 -> Json.Encode.Value
encodeSearchResultLevel5 =
    encodeObject << encodeSearchResultLevel5Pairs


encodeSearchResultLevel5WithTag : ( String, String ) -> SearchResultLevel5 -> Json.Encode.Value
encodeSearchResultLevel5WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel5Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel5Pairs : SearchResultLevel5 -> List EncodedField
encodeSearchResultLevel5Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLevel6) model.paths
            ]
    in
    pairs


encodeSearchResultLevel6 : SearchResultLevel6 -> Json.Encode.Value
encodeSearchResultLevel6 =
    encodeObject << encodeSearchResultLevel6Pairs


encodeSearchResultLevel6WithTag : ( String, String ) -> SearchResultLevel6 -> Json.Encode.Value
encodeSearchResultLevel6WithTag (tagField, tag) model =
    encodeObject (encodeSearchResultLevel6Pairs model ++ [ encode tagField Json.Encode.string tag ])


encodeSearchResultLevel6Pairs : SearchResultLevel6 -> List EncodedField
encodeSearchResultLevel6Pairs model =
    let
        pairs =
            [ maybeEncode "node" encodeEntity model.node
            , maybeEncode "relation" encodeNeighbor model.relation
            , maybeEncode "matching_addresses" (Json.Encode.list encodeAddress) model.matchingAddresses
            , maybeEncode "paths" (Json.Encode.list encodeSearchResultLeaf) model.paths
            ]
    in
    pairs


encodeStats : Stats -> Json.Encode.Value
encodeStats =
    encodeObject << encodeStatsPairs


encodeStatsWithTag : ( String, String ) -> Stats -> Json.Encode.Value
encodeStatsWithTag (tagField, tag) model =
    encodeObject (encodeStatsPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeStatsPairs : Stats -> List EncodedField
encodeStatsPairs model =
    let
        pairs =
            [ maybeEncode "currencies" (Json.Encode.list encodeCurrencyStats) model.currencies
            , maybeEncode "version" Json.Encode.string model.version
            , maybeEncode "request_timestamp" Json.Encode.string model.requestTimestamp
            ]
    in
    pairs


encodeTag : Tag -> Json.Encode.Value
encodeTag =
    encodeObject << encodeTagPairs


encodeTagWithTag : ( String, String ) -> Tag -> Json.Encode.Value
encodeTagWithTag (tagField, tag) model =
    encodeObject (encodeTagPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTagPairs : Tag -> List EncodedField
encodeTagPairs model =
    let
        pairs =
            [ encode "label" Json.Encode.string model.label
            , maybeEncode "category" Json.Encode.string model.category
            , maybeEncode "abuse" Json.Encode.string model.abuse
            , maybeEncode "tagpack_uri" Json.Encode.string model.tagpackUri
            , maybeEncode "source" Json.Encode.string model.source
            , maybeEncode "lastmod" Json.Encode.int model.lastmod
            , encode "active" Json.Encode.bool model.active
            , maybeEncode "is_public" Json.Encode.bool model.isPublic
            , maybeEncode "is_cluster_definer" Json.Encode.bool model.isClusterDefiner
            , encode "currency" Json.Encode.string model.currency
            ]
    in
    pairs


encodeTags : Tags -> Json.Encode.Value
encodeTags model =
    case model of
        TagsAddressTags subModel ->
            encodeAddressTags subModel


        TagsEntityTags subModel ->
            encodeEntityTags subModel




encodeTaxonomy : Taxonomy -> Json.Encode.Value
encodeTaxonomy =
    encodeObject << encodeTaxonomyPairs


encodeTaxonomyWithTag : ( String, String ) -> Taxonomy -> Json.Encode.Value
encodeTaxonomyWithTag (tagField, tag) model =
    encodeObject (encodeTaxonomyPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTaxonomyPairs : Taxonomy -> List EncodedField
encodeTaxonomyPairs model =
    let
        pairs =
            [ encode "taxonomy" Json.Encode.string model.taxonomy
            , encode "uri" Json.Encode.string model.uri
            ]
    in
    pairs


encodeTaxonomyKey : TaxonomyKey -> Json.Encode.Value
encodeTaxonomyKey =
    encodeObject << encodeTaxonomyKeyPairs


encodeTaxonomyKeyWithTag : ( String, String ) -> TaxonomyKey -> Json.Encode.Value
encodeTaxonomyKeyWithTag (tagField, tag) model =
    encodeObject (encodeTaxonomyKeyPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTaxonomyKeyPairs : TaxonomyKey -> List EncodedField
encodeTaxonomyKeyPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeTimestamp : Timestamp -> Json.Encode.Value
encodeTimestamp =
    encodeObject << encodeTimestampPairs


encodeTimestampWithTag : ( String, String ) -> Timestamp -> Json.Encode.Value
encodeTimestampWithTag (tagField, tag) model =
    encodeObject (encodeTimestampPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTimestampPairs : Timestamp -> List EncodedField
encodeTimestampPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeTx : Tx -> Json.Encode.Value
encodeTx model =
    case model of
        TxTxAccount subModel ->
            encodeTxAccountWithTag ("txType", "account") subModel

        TxTxUtxo subModel ->
            encodeTxUtxoWithTag ("txType", "utxo") subModel




encodeTxAccount : TxAccount -> Json.Encode.Value
encodeTxAccount =
    encodeObject << encodeTxAccountPairs


encodeTxAccountWithTag : ( String, String ) -> TxAccount -> Json.Encode.Value
encodeTxAccountWithTag (tagField, tag) model =
    encodeObject (encodeTxAccountPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTxAccountPairs : TxAccount -> List EncodedField
encodeTxAccountPairs model =
    let
        pairs =
            [ encode "tx_type" Json.Encode.string model.txType
            , encode "tx_hash" Json.Encode.string model.txHash
            , encode "height" Json.Encode.int model.height
            , encode "timestamp" Json.Encode.int model.timestamp
            , encode "value" encodeValues model.value
            , encode "from_address" Json.Encode.string model.fromAddress
            , encode "to_address" Json.Encode.string model.toAddress
            ]
    in
    pairs


encodeTxHash : TxHash -> Json.Encode.Value
encodeTxHash =
    encodeObject << encodeTxHashPairs


encodeTxHashWithTag : ( String, String ) -> TxHash -> Json.Encode.Value
encodeTxHashWithTag (tagField, tag) model =
    encodeObject (encodeTxHashPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTxHashPairs : TxHash -> List EncodedField
encodeTxHashPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeTxSummary : TxSummary -> Json.Encode.Value
encodeTxSummary =
    encodeObject << encodeTxSummaryPairs


encodeTxSummaryWithTag : ( String, String ) -> TxSummary -> Json.Encode.Value
encodeTxSummaryWithTag (tagField, tag) model =
    encodeObject (encodeTxSummaryPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTxSummaryPairs : TxSummary -> List EncodedField
encodeTxSummaryPairs model =
    let
        pairs =
            [ encode "height" Json.Encode.int model.height
            , encode "timestamp" Json.Encode.int model.timestamp
            , encode "tx_hash" Json.Encode.string model.txHash
            ]
    in
    pairs


encodeTxUtxo : TxUtxo -> Json.Encode.Value
encodeTxUtxo =
    encodeObject << encodeTxUtxoPairs


encodeTxUtxoWithTag : ( String, String ) -> TxUtxo -> Json.Encode.Value
encodeTxUtxoWithTag (tagField, tag) model =
    encodeObject (encodeTxUtxoPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTxUtxoPairs : TxUtxo -> List EncodedField
encodeTxUtxoPairs model =
    let
        pairs =
            [ encode "tx_type" Json.Encode.string model.txType
            , encode "tx_hash" Json.Encode.string model.txHash
            , encode "coinbase" Json.Encode.bool model.coinbase
            , encode "height" Json.Encode.int model.height
            , maybeEncode "inputs" (Json.Encode.list encodeTxValue) model.inputs
            , maybeEncode "outputs" (Json.Encode.list encodeTxValue) model.outputs
            , encode "timestamp" Json.Encode.int model.timestamp
            , encode "total_input" encodeValues model.totalInput
            , encode "total_output" encodeValues model.totalOutput
            ]
    in
    pairs


encodeTxValue : TxValue -> Json.Encode.Value
encodeTxValue =
    encodeObject << encodeTxValuePairs


encodeTxValueWithTag : ( String, String ) -> TxValue -> Json.Encode.Value
encodeTxValueWithTag (tagField, tag) model =
    encodeObject (encodeTxValuePairs model ++ [ encode tagField Json.Encode.string tag ])


encodeTxValuePairs : TxValue -> List EncodedField
encodeTxValuePairs model =
    let
        pairs =
            [ encode "address" (Json.Encode.list Json.Encode.string) model.address
            , encode "value" encodeValues model.value
            ]
    in
    pairs


encodeUri : Uri -> Json.Encode.Value
encodeUri =
    encodeObject << encodeUriPairs


encodeUriWithTag : ( String, String ) -> Uri -> Json.Encode.Value
encodeUriWithTag (tagField, tag) model =
    encodeObject (encodeUriPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeUriPairs : Uri -> List EncodedField
encodeUriPairs model =
    let
        pairs =
            ]
    in
    pairs


encodeValues : Values -> Json.Encode.Value
encodeValues =
    encodeObject << encodeValuesPairs


encodeValuesWithTag : ( String, String ) -> Values -> Json.Encode.Value
encodeValuesWithTag (tagField, tag) model =
    encodeObject (encodeValuesPairs model ++ [ encode tagField Json.Encode.string tag ])


encodeValuesPairs : Values -> List EncodedField
encodeValuesPairs model =
    let
        pairs =
            [ maybeEncode "fiat_values" (Json.Encode.list encodeRate) model.fiatValues
            , maybeEncode "value" Json.Encode.int model.value
            ]
    in
    pairs


-- DECODER


addressDecoder : Json.Decode.Decoder Address
addressDecoder =
    Json.Decode.succeed Address
        |> decode "address" Json.Decode.string 
        |> decode "entity" Json.Decode.int 
        |> decode "balance" valuesDecoder 
        |> decode "first_tx" txSummaryDecoder 
        |> decode "last_tx" txSummaryDecoder 
        |> decode "in_degree" Json.Decode.int 
        |> decode "out_degree" Json.Decode.int 
        |> decode "no_incoming_txs" Json.Decode.int 
        |> decode "no_outgoing_txs" Json.Decode.int 
        |> decode "total_received" valuesDecoder 
        |> decode "total_spent" valuesDecoder 
        |> maybeDecode "tags" (Json.Decode.list addressTagDecoder) Nothing


addressAndEntityTagsDecoder : Json.Decode.Decoder AddressAndEntityTags
addressAndEntityTagsDecoder =
    Json.Decode.succeed AddressAndEntityTags
        |> decode "entity_tags" (Json.Decode.list entityTagDecoder) 
        |> decode "address_tags" (Json.Decode.list addressTagDecoder) 


addressIdDecoder : Json.Decode.Decoder AddressId
addressIdDecoder =
    Json.Decode.succeed AddressId


addressTagDecoder : Json.Decode.Decoder AddressTag
addressTagDecoder =
    Json.Decode.succeed AddressTag
        |> decode "label" Json.Decode.string 
        |> maybeDecode "category" Json.Decode.string Nothing
        |> maybeDecode "abuse" Json.Decode.string Nothing
        |> maybeDecode "tagpack_uri" Json.Decode.string Nothing
        |> maybeDecode "source" Json.Decode.string Nothing
        |> maybeDecode "lastmod" Json.Decode.int Nothing
        |> decode "active" Json.Decode.bool 
        |> maybeDecode "is_public" Json.Decode.bool Nothing
        |> maybeDecode "is_cluster_definer" Json.Decode.bool Nothing
        |> decode "currency" Json.Decode.string 
        |> decode "address" Json.Decode.string 


addressTagsDecoder : Json.Decode.Decoder AddressTags
addressTagsDecoder =
    Json.Decode.succeed AddressTags
        |> decode "address_tags" (Json.Decode.list addressTagDecoder) 
        |> maybeDecode "next_page" Json.Decode.string Nothing


addressTxDecoder : Json.Decode.Decoder AddressTx
addressTxDecoder =
    Json.Decode.field "txType" Json.Decode.string
        |> Json.Decode.andThen addressTxTagDecoder


addressTxTagDecoder : String -> Json.Decode.Decoder AddressTx
addressTxTagDecoder tag =
    case tag of
        "account" ->
            Json.Decode.map AddressTxTxAccount txAccountDecoder

        "utxo" ->
            Json.Decode.map AddressTxAddressTxUtxo addressTxUtxoDecoder

        _ ->
            Json.Decode.fail <| "Trying to decode AddressTx, but txType '" ++ tag ++ "' is not supported."



addressTxUtxoDecoder : Json.Decode.Decoder AddressTxUtxo
addressTxUtxoDecoder =
    Json.Decode.succeed AddressTxUtxo
        |> decode "tx_type" Json.Decode.string 
        |> decode "tx_hash" Json.Decode.string 
        |> decode "coinbase" Json.Decode.bool 
        |> decode "height" Json.Decode.int 
        |> decode "timestamp" Json.Decode.int 
        |> decode "value" valuesDecoder 


addressTxsDecoder : Json.Decode.Decoder AddressTxs
addressTxsDecoder =
    Json.Decode.succeed AddressTxs
        |> maybeDecode "next_page" Json.Decode.string Nothing
        |> maybeDecode "address_txs" (Json.Decode.list addressTxDecoder) Nothing


blockDecoder : Json.Decode.Decoder Block
blockDecoder =
    Json.Decode.succeed Block
        |> maybeDecode "block_hash" Json.Decode.string Nothing
        |> maybeDecode "height" Json.Decode.int Nothing
        |> maybeDecode "no_txs" Json.Decode.int Nothing
        |> maybeDecode "timestamp" Json.Decode.int Nothing


coinbaseDecoder : Json.Decode.Decoder Coinbase
coinbaseDecoder =
    Json.Decode.succeed Coinbase


conceptDecoder : Json.Decode.Decoder Concept
conceptDecoder =
    Json.Decode.succeed Concept
        |> decode "label" Json.Decode.string 
        |> decode "taxonomy" Json.Decode.string 
        |> decode "uri" Json.Decode.string 
        |> decode "description" Json.Decode.string 
        |> decode "id" Json.Decode.string 


currencyDecoder : Json.Decode.Decoder Currency
currencyDecoder =
    Json.Decode.succeed Currency


currencyStatsDecoder : Json.Decode.Decoder CurrencyStats
currencyStatsDecoder =
    Json.Decode.succeed CurrencyStats
        |> maybeDecode "name" Json.Decode.string Nothing
        |> maybeDecode "no_blocks" Json.Decode.int Nothing
        |> maybeDecode "no_address_relations" Json.Decode.int Nothing
        |> maybeDecode "no_addresses" Json.Decode.int Nothing
        |> maybeDecode "no_entities" Json.Decode.int Nothing
        |> maybeDecode "no_txs" Json.Decode.int Nothing
        |> maybeDecode "no_labels" Json.Decode.int Nothing
        |> maybeDecode "no_tagged_addresses" Json.Decode.int Nothing
        |> maybeDecode "timestamp" Json.Decode.int Nothing


entityDecoder : Json.Decode.Decoder Entity
entityDecoder =
    Json.Decode.succeed Entity
        |> decode "entity" Json.Decode.int 
        |> decode "root_address" Json.Decode.string 
        |> decode "balance" valuesDecoder 
        |> decode "first_tx" txSummaryDecoder 
        |> decode "last_tx" txSummaryDecoder 
        |> decode "in_degree" Json.Decode.int 
        |> decode "out_degree" Json.Decode.int 
        |> decode "no_addresses" Json.Decode.int 
        |> decode "no_incoming_txs" Json.Decode.int 
        |> decode "no_outgoing_txs" Json.Decode.int 
        |> decode "total_received" valuesDecoder 
        |> decode "total_spent" valuesDecoder 
        |> maybeDecode "tags" addressAndEntityTagsDecoder Nothing


entityAddressesDecoder : Json.Decode.Decoder EntityAddresses
entityAddressesDecoder =
    Json.Decode.succeed EntityAddresses
        |> maybeDecode "next_page" Json.Decode.string Nothing
        |> maybeDecode "addresses" (Json.Decode.list addressDecoder) Nothing


entityIdDecoder : Json.Decode.Decoder EntityId
entityIdDecoder =
    Json.Decode.succeed EntityId


entityTagDecoder : Json.Decode.Decoder EntityTag
entityTagDecoder =
    Json.Decode.succeed EntityTag
        |> decode "label" Json.Decode.string 
        |> maybeDecode "category" Json.Decode.string Nothing
        |> maybeDecode "abuse" Json.Decode.string Nothing
        |> maybeDecode "tagpack_uri" Json.Decode.string Nothing
        |> maybeDecode "source" Json.Decode.string Nothing
        |> maybeDecode "lastmod" Json.Decode.int Nothing
        |> decode "active" Json.Decode.bool 
        |> maybeDecode "is_public" Json.Decode.bool Nothing
        |> maybeDecode "is_cluster_definer" Json.Decode.bool Nothing
        |> decode "currency" Json.Decode.string 
        |> decode "entity" Json.Decode.int 
        |> maybeDecode "address" Json.Decode.string Nothing


entityTagsDecoder : Json.Decode.Decoder EntityTags
entityTagsDecoder =
    Json.Decode.succeed EntityTags
        |> decode "entity_tags" (Json.Decode.list entityTagDecoder) 
        |> maybeDecode "next_page" Json.Decode.string Nothing


heightDecoder : Json.Decode.Decoder Height
heightDecoder =
    Json.Decode.succeed Height


labelDecoder : Json.Decode.Decoder Label
labelDecoder =
    Json.Decode.succeed Label


linkDecoder : Json.Decode.Decoder Link
linkDecoder =
    Json.Decode.field "txType" Json.Decode.string
        |> Json.Decode.andThen linkTagDecoder


linkTagDecoder : String -> Json.Decode.Decoder Link
linkTagDecoder tag =
    case tag of
        "account" ->
            Json.Decode.map LinkTxAccount txAccountDecoder

        "utxo" ->
            Json.Decode.map LinkLinkUtxo linkUtxoDecoder

        _ ->
            Json.Decode.fail <| "Trying to decode Link, but txType '" ++ tag ++ "' is not supported."



linkUtxoDecoder : Json.Decode.Decoder LinkUtxo
linkUtxoDecoder =
    Json.Decode.succeed LinkUtxo
        |> decode "tx_type" Json.Decode.string 
        |> decode "tx_hash" Json.Decode.string 
        |> decode "height" Json.Decode.int 
        |> decode "timestamp" Json.Decode.int 
        |> decode "input_value" valuesDecoder 
        |> decode "output_value" valuesDecoder 


linksDecoder : Json.Decode.Decoder Links
linksDecoder =
    Json.Decode.succeed Links
        |> maybeDecode "next_page" Json.Decode.string Nothing
        |> maybeDecode "links" (Json.Decode.list linkDecoder) Nothing


neighborDecoder : Json.Decode.Decoder Neighbor
neighborDecoder =
    Json.Decode.succeed Neighbor
        |> decode "id" Json.Decode.string 
        |> decode "node_type"  
        |> maybeDecode "labels" (Json.Decode.list Json.Decode.string) Nothing
        |> decode "balance" valuesDecoder 
        |> decode "received" valuesDecoder 
        |> decode "value" valuesDecoder 
        |> decode "no_txs" Json.Decode.int 


neighborNodeTypeDecoder : Json.Decode.Decoder NeighborNodeType
neighborNodeTypeDecoder =
    Json.Decode.string
        |> Json.Decode.andThen
            (\value ->
                case value of
                    "address" ->
                        Json.Decode.succeed NeighborNodeTypeAddress

                    "entity" ->
                        Json.Decode.succeed NeighborNodeTypeEntity

                    other ->
                        Json.Decode.fail <| "Unknown type: " ++ other
            )



neighborsDecoder : Json.Decode.Decoder Neighbors
neighborsDecoder =
    Json.Decode.succeed Neighbors
        |> maybeDecode "next_page" Json.Decode.string Nothing
        |> maybeDecode "neighbors" (Json.Decode.list neighborDecoder) Nothing


nextPageDecoder : Json.Decode.Decoder NextPage
nextPageDecoder =
    Json.Decode.succeed NextPage


noAddressesDecoder : Json.Decode.Decoder NoAddresses
noAddressesDecoder =
    Json.Decode.succeed NoAddresses


noTxsDecoder : Json.Decode.Decoder NoTxs
noTxsDecoder =
    Json.Decode.succeed NoTxs


rateDecoder : Json.Decode.Decoder Rate
rateDecoder =
    Json.Decode.succeed Rate
        |> maybeDecode "code" Json.Decode.string Nothing
        |> maybeDecode "value" Json.Decode.float Nothing


ratesDecoder : Json.Decode.Decoder Rates
ratesDecoder =
    Json.Decode.succeed Rates
        |> maybeDecode "height" Json.Decode.int Nothing
        |> maybeDecode "rates" (Json.Decode.list rateDecoder) Nothing


searchResultDecoder : Json.Decode.Decoder SearchResult
searchResultDecoder =
    Json.Decode.succeed SearchResult
        |> maybeDecode "currencies" (Json.Decode.list searchResultByCurrencyDecoder) Nothing
        |> maybeDecode "labels" (Json.Decode.list Json.Decode.string) Nothing


searchResultByCurrencyDecoder : Json.Decode.Decoder SearchResultByCurrency
searchResultByCurrencyDecoder =
    Json.Decode.succeed SearchResultByCurrency
        |> maybeDecode "currency" Json.Decode.string Nothing
        |> maybeDecode "addresses" (Json.Decode.list Json.Decode.string) Nothing
        |> maybeDecode "txs" (Json.Decode.list Json.Decode.string) Nothing


searchResultLeafDecoder : Json.Decode.Decoder SearchResultLeaf
searchResultLeafDecoder =
    Json.Decode.succeed SearchResultLeaf
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing


searchResultLevel1Decoder : Json.Decode.Decoder SearchResultLevel1
searchResultLevel1Decoder =
    Json.Decode.succeed SearchResultLevel1
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLevel2Decoder) Nothing


searchResultLevel2Decoder : Json.Decode.Decoder SearchResultLevel2
searchResultLevel2Decoder =
    Json.Decode.succeed SearchResultLevel2
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLevel3Decoder) Nothing


searchResultLevel3Decoder : Json.Decode.Decoder SearchResultLevel3
searchResultLevel3Decoder =
    Json.Decode.succeed SearchResultLevel3
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLevel4Decoder) Nothing


searchResultLevel4Decoder : Json.Decode.Decoder SearchResultLevel4
searchResultLevel4Decoder =
    Json.Decode.succeed SearchResultLevel4
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLevel5Decoder) Nothing


searchResultLevel5Decoder : Json.Decode.Decoder SearchResultLevel5
searchResultLevel5Decoder =
    Json.Decode.succeed SearchResultLevel5
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLevel6Decoder) Nothing


searchResultLevel6Decoder : Json.Decode.Decoder SearchResultLevel6
searchResultLevel6Decoder =
    Json.Decode.succeed SearchResultLevel6
        |> maybeDecode "node" entityDecoder Nothing
        |> maybeDecode "relation" neighborDecoder Nothing
        |> maybeDecode "matching_addresses" (Json.Decode.list addressDecoder) Nothing
        |> maybeDecode "paths" (Json.Decode.list searchResultLeafDecoder) Nothing


statsDecoder : Json.Decode.Decoder Stats
statsDecoder =
    Json.Decode.succeed Stats
        |> maybeDecode "currencies" (Json.Decode.list currencyStatsDecoder) Nothing
        |> maybeDecode "version" Json.Decode.string Nothing
        |> maybeDecode "request_timestamp" Json.Decode.string Nothing


tagDecoder : Json.Decode.Decoder Tag
tagDecoder =
    Json.Decode.succeed Tag
        |> decode "label" Json.Decode.string 
        |> maybeDecode "category" Json.Decode.string Nothing
        |> maybeDecode "abuse" Json.Decode.string Nothing
        |> maybeDecode "tagpack_uri" Json.Decode.string Nothing
        |> maybeDecode "source" Json.Decode.string Nothing
        |> maybeDecode "lastmod" Json.Decode.int Nothing
        |> decode "active" Json.Decode.bool 
        |> maybeDecode "is_public" Json.Decode.bool Nothing
        |> maybeDecode "is_cluster_definer" Json.Decode.bool Nothing
        |> decode "currency" Json.Decode.string 


tagsDecoder : Json.Decode.Decoder Tags
tagsDecoder =
    Json.Decode.oneOf
        [ Json.Decode.map TagsAddressTags addressTagsDecoder
        , Json.Decode.map TagsEntityTags entityTagsDecoder
        ]



taxonomyDecoder : Json.Decode.Decoder Taxonomy
taxonomyDecoder =
    Json.Decode.succeed Taxonomy
        |> decode "taxonomy" Json.Decode.string 
        |> decode "uri" Json.Decode.string 


taxonomyKeyDecoder : Json.Decode.Decoder TaxonomyKey
taxonomyKeyDecoder =
    Json.Decode.succeed TaxonomyKey


timestampDecoder : Json.Decode.Decoder Timestamp
timestampDecoder =
    Json.Decode.succeed Timestamp


txDecoder : Json.Decode.Decoder Tx
txDecoder =
    Json.Decode.field "txType" Json.Decode.string
        |> Json.Decode.andThen txTagDecoder


txTagDecoder : String -> Json.Decode.Decoder Tx
txTagDecoder tag =
    case tag of
        "account" ->
            Json.Decode.map TxTxAccount txAccountDecoder

        "utxo" ->
            Json.Decode.map TxTxUtxo txUtxoDecoder

        _ ->
            Json.Decode.fail <| "Trying to decode Tx, but txType '" ++ tag ++ "' is not supported."



txAccountDecoder : Json.Decode.Decoder TxAccount
txAccountDecoder =
    Json.Decode.succeed TxAccount
        |> decode "tx_type" Json.Decode.string 
        |> decode "tx_hash" Json.Decode.string 
        |> decode "height" Json.Decode.int 
        |> decode "timestamp" Json.Decode.int 
        |> decode "value" valuesDecoder 
        |> decode "from_address" Json.Decode.string 
        |> decode "to_address" Json.Decode.string 


txHashDecoder : Json.Decode.Decoder TxHash
txHashDecoder =
    Json.Decode.succeed TxHash


txSummaryDecoder : Json.Decode.Decoder TxSummary
txSummaryDecoder =
    Json.Decode.succeed TxSummary
        |> decode "height" Json.Decode.int 
        |> decode "timestamp" Json.Decode.int 
        |> decode "tx_hash" Json.Decode.string 


txUtxoDecoder : Json.Decode.Decoder TxUtxo
txUtxoDecoder =
    Json.Decode.succeed TxUtxo
        |> decode "tx_type" Json.Decode.string 
        |> decode "tx_hash" Json.Decode.string 
        |> decode "coinbase" Json.Decode.bool 
        |> decode "height" Json.Decode.int 
        |> maybeDecode "inputs" (Json.Decode.list txValueDecoder) Nothing
        |> maybeDecode "outputs" (Json.Decode.list txValueDecoder) Nothing
        |> decode "timestamp" Json.Decode.int 
        |> decode "total_input" valuesDecoder 
        |> decode "total_output" valuesDecoder 


txValueDecoder : Json.Decode.Decoder TxValue
txValueDecoder =
    Json.Decode.succeed TxValue
        |> decode "address" (Json.Decode.list Json.Decode.string) 
        |> decode "value" valuesDecoder 


uriDecoder : Json.Decode.Decoder Uri
uriDecoder =
    Json.Decode.succeed Uri


valuesDecoder : Json.Decode.Decoder Values
valuesDecoder =
    Json.Decode.succeed Values
        |> maybeDecode "fiat_values" (Json.Decode.list rateDecoder) Nothing
        |> maybeDecode "value" Json.Decode.int Nothing




-- HELPER


type alias EncodedField =
    Maybe ( String, Json.Encode.Value )


encodeObject : List EncodedField -> Json.Encode.Value
encodeObject =
    Json.Encode.object << List.filterMap identity


encode : String -> (a -> Json.Encode.Value) -> a -> EncodedField
encode key encoder value =
    Just ( key, encoder value )


encodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
encodeNullable key encoder value =
    Just ( key, Maybe.withDefault Json.Encode.null (Maybe.map encoder value) )


maybeEncode : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncode key encoder =
    Maybe.map (Tuple.pair key << encoder)


maybeEncodeNullable : String -> (a -> Json.Encode.Value) -> Maybe a -> EncodedField
maybeEncodeNullable =
    encodeNullable


decode : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decode key decoder =
    decodeChain (Json.Decode.field key decoder)


decodeLazy : (a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeLazy f key decoder =
    decodeChainLazy f (Json.Decode.field key decoder)


decodeNullable : String -> Json.Decode.Decoder a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
decodeNullable key decoder =
    decodeChain (maybeField key decoder Nothing)


decodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeNullableLazy f key decoder =
    decodeChainLazy f (maybeField key decoder Nothing)


maybeDecode : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecode key decoder fallback =
    -- let's be kind to null-values as well
    decodeChain (maybeField key decoder fallback)


maybeDecodeLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeLazy f key decoder fallback =
    -- let's be kind to null-values as well
    decodeChainLazy f (maybeField key decoder fallback)


maybeDecodeNullable : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a -> b) -> Json.Decode.Decoder b
maybeDecodeNullable key decoder fallback =
    decodeChain (maybeField key decoder fallback)


maybeDecodeNullableLazy : (Maybe a -> c) -> String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
maybeDecodeNullableLazy f key decoder fallback =
    decodeChainLazy f (maybeField key decoder fallback)


maybeField : String -> Json.Decode.Decoder a -> Maybe a -> Json.Decode.Decoder (Maybe a)
maybeField key decoder fallback =
    let
        fieldDecoder =
            Json.Decode.field key Json.Decode.value

        valueDecoder =
            Json.Decode.oneOf [ Json.Decode.map Just decoder, Json.Decode.null fallback ]

        decodeObject rawObject =
            case Json.Decode.decodeValue fieldDecoder rawObject of
                Ok rawValue ->
                    case Json.Decode.decodeValue valueDecoder rawValue of
                        Ok value ->
                            Json.Decode.succeed value

                        Err error ->
                            Json.Decode.fail (Json.Decode.errorToString error)

                Err _ ->
                    Json.Decode.succeed fallback
    in
    Json.Decode.value
        |> Json.Decode.andThen decodeObject


decodeChain : Json.Decode.Decoder a -> Json.Decode.Decoder (a -> b) -> Json.Decode.Decoder b
decodeChain =
    Json.Decode.map2 (|>)


decodeChainLazy : (a -> c) -> Json.Decode.Decoder a -> Json.Decode.Decoder (c -> b) -> Json.Decode.Decoder b
decodeChainLazy f =
    decodeChain << Json.Decode.map f